<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Blob</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script src="https://fariskassim.com/stage/rebel9/teaf/blob/v4/js/perlin.js"></script>
    <script type="module">
      import * as THREE from "../../build/three.module.js";

      import { OrbitControls } from "../jsm/controls/OrbitControls.js";
      import { EffectComposer } from "../jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "../jsm/postprocessing/RenderPass.js";
      import { GlitchPass } from "../jsm/postprocessing/GlitchPass.js";
      import { ShaderPass } from "../jsm/postprocessing/ShaderPass.js";
      import { LuminosityShader } from "../jsm/shaders/LuminosityShader.js";

      var renderer, camera, scene, raycaster;
      var mouse = new THREE.Vector2(),
        intersectedObj;

      var radius = 100,
        theta = 0;

      var sphere;
      var composer;
      init();
      animate();

      function init() {
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        // set size of canvas within window //
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;

        composer = new EffectComposer(renderer);
        var renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        /*    var glitchPass = new GlitchPass();
             composer.addPass(glitchPass);
      */
        var luminosityPass = new ShaderPass(LuminosityShader);
        composer.addPass(luminosityPass);
        console.log(luminosityPass);

        //add raycaster
        raycaster = new THREE.Raycaster();

        var light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(10, 0, 10);
        light.castShadow = true; // default false
        scene.add(light);

        var sphere_geometry = new THREE.SphereGeometry(1, 128, 128);
        //var material = new THREE.MeshNormalMaterial();
        var material = new THREE.MeshStandardMaterial({ color: 0x2194ce });
        sphere = new THREE.Mesh(sphere_geometry, material);

        scene.add(sphere);
        document.addEventListener("resize", onResize, false);
        document.addEventListener("mousemove", highlight, false);
      }

      function highlight(e) {
        e.preventDefault();
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = (e.clientY / window.innerHeight) * 2 - 1;
      }

      function update() {
        var time = performance.now() * 0.0015;
        //console.log(time)

        //go through vertices here and reposition them

        // change 'k' value for more spikes
        var k = 1.2;
        for (var i = 0; i < sphere.geometry.vertices.length; i++) {
          var p = sphere.geometry.vertices[i];
          p.normalize().multiplyScalar(
            1 + 0.3 * noise.perlin3(p.x * k + time, p.y * k, p.z * k + time)
          );
        }
        sphere.geometry.computeVertexNormals();
        sphere.geometry.normalsNeedUpdate = true;
        sphere.geometry.verticesNeedUpdate = true;
      }
      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      var intersects;
      function render() {
        theta += 0.1;

        raycaster.setFromCamera(mouse, camera);
        intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          if (intersectedObj != intersects[0].object) {
            //if move to new object, set the emissive back
            if (intersectedObj)
              intersectedObj.material.emissive.setHex(
                intersectedObj.currentHex
              );

            intersectedObj = intersects[0].object;
            console.log(intersectedObj);

            //save current emissive value to revert when mouse leaves
            intersectedObj.currentHex = intersectedObj.material.emissive.getHex();
            intersectedObj.material.emissive.setHex(0xffffff);
          }
        } else {
          if (intersectedObj)
            intersectedObj.material.emissive.setHex(intersectedObj.currentHex);

          intersectedObj = null;
        }
      }
      function animate() {
        //sphere.rotation.x += 0.01;
        //sphere.rotation.y += 0.01;

        update();
        render();
        renderer.render(scene, camera);
        composer.render();
        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>

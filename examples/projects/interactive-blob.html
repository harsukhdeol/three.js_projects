<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Blob</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script src="https://fariskassim.com/stage/rebel9/teaf/blob/v4/js/perlin.js"></script>
    <script type="module">
      import * as THREE from "../../build/three.module.js";

      import { OrbitControls } from "../jsm/controls/OrbitControls.js";
      import { EffectComposer } from "../jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "../jsm/postprocessing/RenderPass.js";
      import { GlitchPass } from "../jsm/postprocessing/GlitchPass.js";
      import { ShaderPass } from "../jsm/postprocessing/ShaderPass.js";
      import { LuminosityShader } from "../jsm/shaders/LuminosityShader.js";

      var renderer, camera, scene, raycaster, controls;
      var mouse = new THREE.Vector2(),
        intersectedObj;

      var grayMat, colorMat;
      var blobs = [];
      var composer;

      class Blob {
        constructor(spacing = 5, pos = 0) {
          this.speed = 0.0005;
          this.x = Math.random() * spacing - pos;
          this.y = Math.random() * spacing - pos;
          this.z = Math.random() * spacing - pos;
          this.sphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 128, 128),
            grayMat
          );
        }

        draw() {
          this.sphere.position.set(this.x, this.y, this.z);
          scene.add(this.sphere);
        }
        update() {
          var distort = 0.5; //how much farther away from the regular sphere geometry you want the points to go - max =size
          var time = performance.now() * this.speed;
          //console.log(time)

          //go through vertices here and reposition them

          // change 'k' value for more spikes
          var k = 0.5;
          noise.seed(this.x);
          for (var i = 0; i < this.sphere.geometry.vertices.length; i++) {
            var p = this.sphere.geometry.vertices[i];
            p.normalize().multiplyScalar(
              0.5 +
                distort * noise.perlin3(p.x * k, p.y * k + time, p.z * k + time)
            );
          }
          this.sphere.geometry.computeVertexNormals();
          this.sphere.geometry.normalsNeedUpdate = true;
          this.sphere.geometry.verticesNeedUpdate = true;
        }
        render() {
          raycaster.setFromCamera(mouse, camera);
          var intersects = raycaster.intersectObjects(scene.children);

          if (intersects.length > 0) {
            console.log(intersects[0].object.id);

            if (intersects[0].object == this.sphere) {
              //save current emissive value to revert when mouse leaves
              //  intersectedObj.currentHex = intersectedObj.material.emissive.getHex();
              this.sphere.material = colorMat;
              this.speed = 0.008;
            } else {
              //  intersectedObj.material.emissive.setHex(intersectedObj.currentHex);
              this.sphere.material = grayMat;
              this.speed = 0.0005;
            }
          } else {
            this.sphere.material = grayMat;
            this.speed = 0.0005;
          }
        }
      }

      init();
      animate();

      function init() {
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("canvas"),
          antialias: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        // set size of canvas within window //
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 15;

        composer = new EffectComposer(renderer);
        var renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        /*    var glitchPass = new GlitchPass();
             composer.addPass(glitchPass);
      */
        /*   var luminosityPass = new ShaderPass(LuminosityShader);
        composer.addPass(luminosityPass);
        console.log(luminosityPass); */

        //add raycaster
        raycaster = new THREE.Raycaster();

        var light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(10, 0, 10);
        light.castShadow = true; // default false
        scene.add(light);

        var ambientLight = new THREE.AmbientLight(0xffffff);
        //scene.add(ambientLight);

        //create materials
        colorMat = new THREE.MeshNormalMaterial();
        grayMat = new THREE.MeshStandardMaterial({ color: 0xbbbbbb });

        //create blobs array
        const numBlobs = 3;
        for (let i = 0; i < numBlobs; i++) {
          let blob = new Blob();
          console.log(blob);
          blob.draw();
          blobs.push(blob);
        }
        controls = new OrbitControls(camera, renderer.domElement);

        document.addEventListener("resize", onResize, false);
        document.addEventListener("mousemove", highlight, false);
      }

      function highlight(e) {
        e.preventDefault();
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function render() {
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          if (intersectedObj != intersects[0].object) {
            //if move to new object, set the emissive back
            if (intersectedObj) intersectedObj.material = grayMat;

            intersectedObj = intersects[0].object;
            console.log(intersectedObj);

            //save current emissive value to revert when mouse leaves
            //  intersectedObj.currentHex = intersectedObj.material.emissive.getHex();
            intersectedObj.material = colorMat;
          }
        } else {
          if (intersectedObj)
            //  intersectedObj.material.emissive.setHex(intersectedObj.currentHex);
            intersectedObj.material = grayMat;
          intersectedObj = null;
        }
      }
      function animate() {
        //sphere.rotation.x += 0.01;
        //sphere.rotation.y += 0.01;
        for (let i = 0; i < blobs.length; i++) {
          blobs[i].update();
          blobs[i].render();
        }
        // render();
        renderer.render(scene, camera);
        composer.render();
        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>
